# Setup

## Environment 

### Docker (recommended)

All basic operations are designed and tested in the GO devops docker environment (i.e. all commands take place inside the docker container).
This is the recommended way to do devops.
To pin up the provided dockerized development environment:

```
docker run --name go-dev -it geneontology/go-devops-base:tools-jammy-0.4.1  /bin/bash
```

### Manual (good luck!)

#### Software

- Terraform: v1.1.4
- Ansible: 2.10.7
- aws cli
- go-deploy (multple install methods: poetry `poetry install go-deploy==0.4.2` (requires python >=3.8), can also be installed incidentally from go-fastapi repo with `poetry install`)

## DNS / Cloudflare: 

Two DNS records are used for most services; they are typically the "production" record and the dev/testing record.

Pattern; where SERVICE is a used service CNAME/subdomain, like “api”, “rdf”, “amigo”.
go-workspace-SERVICE
SERVICE-a
SERVICE-b
one of these will be prod; the other will be either the fallback or the next; if for some reason we need both fallback and next, SERVICE-c could be used, but would indicate that we’re climbing over ourselves
SERVICE-dev-DEVNAME(-ISODATE/METADATA)


The go-deploy tool allows for creating DNS records (type A) that would be populated by the public ip addresses of the aws instance. If you don't use this option, you would need to point this record to the elastic IP of the VM. For testing purposes, you can use: `aes-test-go-fastapi.geneontology.org` or any other record that you create in Route 53.

**NOTE**: If using cloudflare, you would need to point the cloudflare dns record to the elastic IP.

#### SSH Keys:

TODO: More info about secrets the go ssh keys.

THESE KEYS!

/tmp/go-ssh.pub
/tmp/go-ssh

2. Prepare AWS credentials WRT GO image:

The credentials are used by Terraform to provision the AWS instance and by the provisioned instance to access the certificate store and the s3 buckets used to store Apache logs.  Copy and modify the aws credential file to the default location `/tmp/go-aws-credentials` 

**NOTE**: you will need to supply an `aws_access_key_id` and `aws_secret_access_key`. These will be marked with `REPLACE_ME` in the `go-aws-credentials.sample` file.

```bash
cp production/go-aws-credentials.sample /tmp/go-aws-credentials
emacs /tmp/go-aws-credentials  # update the `aws_access_key_id` and `aws_secret_access_key`
```

3. Prepare and initialize the S3 Terraform backend:

"Initializing" a Terraform backend means that you are getting ready to save a bundle of EC2 and networking states to S3, so that you and other developers in the future can discover and manipulate these states in the future, bringing servers and services up and down in a coordinated way. These terraform backends are an arbitrary bundle and can be grouped as needed. In general, the production systems should all use a coordinated set, but you may create new ones for experimentation, etc. If you are trying to work with an already set state, jump to `4`; if you are experimenting, continue here with `3`.

```bash

# The S3 backend is used to store the terraform state.
cp ./production/backend.tf.sample ./aws/backend.tf

# replace the REPLACE_ME_GOAPI_S3_STATE_STORE with the appropriate backend
emacs ./aws/backend.tf

# Use the AWS cli to make sure you have access to the terraform s3 backend bucket
export AWS_SHARED_CREDENTIALS_FILE=/tmp/go-aws-credentials

# S3 bucket
aws s3 ls s3://REPLACE_ME_GOAPI_S3_STATE_STORE

# initialize (if it doesn't work, we fail):
go-deploy -init --working-directory aws -verbose

# Use these commands to figure out the name of an existing workspace if any. The name should have a pattern `production-YYYY-MM-DD`
go-deploy --working-directory aws -list-workspaces -verbose 
```
